#! /usr/bin/env python
# -*- coding: utf-8 -*-

import re
import sys
import os

from utils.adbclient import DEBUG, AdbClient
from threading import *
from time import *

from sys import platform
import ctypes
#-------------------------------------------------------------------------------------------------------------------#
#global variables
PORT = 5555
cableOnly = True

adb_path = '.'
output_path = './collected_data/'

if len(sys.argv) >= 2:
    serialno = sys.argv[1]
else:
    serialno = '.*'
#-------------------------------------------------------------------------------------------------------------------#
'''the two class will be used to save the touch input and the accessibility events generated by the user actions.
   to do so we're going to run each of them in a separate thread in order to parallelize the parsing of the data
   that are coming from two different channels at the same time.
'''

class save_touch(Thread):
    def run(self):
        adbclient = AdbClient(serialno=serialno,)
        adbclient.shell('getevent -lrt',output_file=output_path+'touch.txt')



class save_accessibility(Thread):
    def run(self):
        adbclient = AdbClient(serialno=serialno)
        adbclient.shell('uiautomator events',output_file=output_path+'access.txt')

#-------------------------------------------------------------------------------------------------------------------#
# methods definition
def verifyIfNotConnected(adbDevices, ip):
    # Verify if the device is already connected (wifi)
    return adbDevices.find(ip) == -1

def connectToDevice(ip):
    # Connect to an android device on wifi using the specified ip and the default port
    print('Accept prompt one last time it might take up to 1 minute')
    
    os.popen("adb connect " + ip + ":" + str(PORT)).read()

    input("press Enter when you're done") #sleep(3)
    
    ip_addr = getIP()#check if we can still retrieve some data after the connection without the cable

    if ip_addr == ip:
        return True
    else:
        return False


def getDecidesIDs(adbDevices):
    # Get all device IDs connected in an USB port
    return re.findall('(.*?)\tdevice', adbDevices)


def getIP():

    # Find ip from the device connect to teh USB port
    net_stats= os.popen("adb shell ip addr show wlan0").read().rstrip()
    ip_addr = re.findall( r'[0-9]+(?:\.[0-9]+){3}', net_stats )[0]
    
    if ip_addr != '':
        print('Device Detected')
        return ip_addr
    else:
        raise Exception("Sorry, no device detected")
    

def adbOverWiFi():
    #connect the device through wifi and not cable anymore
    os.popen("adb kill-server") # stop an adb server if is already up in order to reset all the existing connections
    print('Accept promtp on the screen')
    #os.chdir(adb_path)
    adbDevices = os.popen("adb start-server").read()#start the adb client need to be in the same dir as adb.exe
    #wait for user to interact

    try:

        ip_addr = getIP()
        #os.chdir(adb_path)
        os.popen("adb tcpip " + str(PORT))
        print("PORT 5555 open for " + ip_addr)
        print('Disconnect device from the cable and press Accept')
        input("Press ENTER when you're done")#sleep(3) # Sleep for 3 seconds


        if (connectToDevice(ip_addr)):
            print("Connected to " + ip_addr)
        else:
            print("Failed to connected to " + ip_addr)
            
    except Exception as ex:
        
        if getIP() != None:
            print('Device connected but some errors occured')
            print("ERROR:", ex, file=sys.stderr)

        else:
            print('ERROR')
            print("ERROR:", ex, file=sys.stderr)

def adbOverCable():
    #connect the device through wifi and not cable anymore
    os.popen("adb kill-server") # stop an adb server if is already up in order to reset all the existing connections
    print('Accept promtp on the screen')
    #os.chdir(adb_path)
    adbDevices = os.popen("adb start-server").read()#start the adb client need to be in the same dir as adb.exe
    return

def saveDeviceInfo(path):#to be called after the device is connected
    adbclient = AdbClient(serialno=serialno,)
    #Alternatives
    #adbclient.getPhysicalDisplayInfo()
    #adbclient.getLogicalDisplayInfo()
    
    screen_info = adbclient.getDisplayInfo() #get display resolution and density
    screen_prop =adbclient.shell('dumpsys display') #get all display properties

    device_prop_list =adbclient.shell('getprop').split('\n') #get all the device propoerties

    #Get a subset of the informations
    device_prop = ''
    for prop in device_prop_list:
        if 'ro.product' in prop:
            device_prop = device_prop + prop +'\n' 


    #save data on file

    f = open(path+'device.txt', 'w')
    f.write(str(device_prop))
    f.close()

    f = open(path+'display.txt', 'w')
    f.write(str(screen_info)+'\n\n')
    f.write(str(screen_prop))
    f.close()
    return 

def define_adb_path():
    global adb_path
    global output_path

    if platform == "linux" or platform == "linux2":
        # linux
        adb_path = './platform-tools/platform-tools_linux/'
    
    elif platform == "darwin":
        # OS X
        adb_path = './platform-tools/platform-tools_darwin/'
    
    elif platform == "win32":
        # Windows..
        adb_path ='./platform-tools/platform-tools_win32/'
        output_path = os.getcwd()+'\\collected_data\\'

def Mbox(title, text, style):
    return ctypes.windll.user32.MessageBoxW(0, text, title, style)

#-------------------------------------------------------------------------------------------------------------------#
#MAIN CODE  
if __name__ == "__main__":
    init = False
    define_adb_path()  
    os.chdir(adb_path)

    if cableOnly:
        adbOverCable()
    else:
        adbOverWiFi()
    
    saveDeviceInfo(output_path)

    app1 = save_touch()
    app2 = save_accessibility()

    print('Start Collecting Data')
    app1.start()
    app2.start()
    while True:
        if not app1.is_alive():
            print("Restart touch collection")
            app1 = save_touch()
            app1.start()
        if not app2.is_alive():
            print("Restart accessibility collection")
            app2 = save_accessibility()
            app2.start()
    app1.join()
    app2.join()

    print('STOPPING THE COLLECTION OF THE RAW DATA')
